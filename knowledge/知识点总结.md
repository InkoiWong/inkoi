# http

## http 协议

1.  定义
2.  url

## http 版本

1.  0.9
2.  1.x
    1.  1.0
        a. 线程阻塞
    2.  1.1
        a. 持久链接
        b. 管道机制
        c. 分块传输
        d. 新增方法
3.  2.0
    a. 二进制格式
    b. 多路复用
    c. 报头压缩
    d. 服务器推送

## TCP

1.  定义
2.  三次握手（四次挥手）

## https

1.  定义
2.  目的
    1.  加密传输
    2.  身份认证
3.  SSL 原理
    a. CA 证书：浏览器校验有效性
    b. 非对称加密：传递对称密钥
    c. 对称加密：密文通信
4.  与 http 对比
    a. 加密 vs 明文
    b. SSL
    c. 利于 SEO（by Google）
    d. 端口 443 vs 80
    e. 传输层 vs 应用层

## http 状态码

    1. 分类
    2. 常用

# 浏览器

## 浏览器运行机制

1.  浏览器是 多进程
    1.  Browser 进程
    2.  GPU 进程
    3.  Renderer 渲染进程
2.  浏览器内核 Renderer 渲染进程是 多线程
    1.  GUI 渲染线程
    2.  JS 引擎线程
    3.  事件触发线程
    4.  定时触发器线程
    5.  异步 http 请求线程
    6.  任务队列轮询线程
3.  梳理浏览器内核中线程之间的关系
    1.  GUI 渲染线程与 JS 引擎线程互斥
    2.  JS 阻塞页面加载
    3.  WebWorker，JS 的多线程？

## 浏览器渲染流程

1.  网络请求
    1.  用户在地址栏输入 URL
    2.  Host 和 DNS 解析 ip 地址（域名解析）
    3.  建立 TCP 链接（三次握手）
    4.  发送 http 请求
    5.  服务器成功响应，发送资源
2.  页面渲染
    1.  html 解析成 DOM
    2.  css 解析成 CSSOM
    3.  DOM + CSSOM 构建 Render 树
    4.  Layout
    5.  Paint
    6.  Load 事件触发 / Repaint + Reflow

## JS 的运行机制

1.  主线程
    1.  stacks 执行栈
2.  其它线程 Web APIs
    1.  DOM API 监听注册事件
    2.  timer 定时任务
    3.  http(ajax) 请求任务
3.  Task Queue 任务队列
    1.  micro task (jobs) 微任务
        1.  process.nextTick
        2.  promise
        3.  Object.observe
        4.  MutationObserver
    2.  macro task (task) 宏任务
        1.  setTimeout
        2.  setInterval
        3.  setImmediate
        4.  I/O
        5.  UI 渲染
4.  Event Loop 事件循环
    1.  执行主线程任务，将 script 压入 stacks
    2.  遇到 异步任务，根据不同情况，压入 macrotask、或者 microtask
    3.  同步执行至`执行栈为空`
    4.  每个 macrotask 执行完，需要检查 microtask 中是否有任务，有则在下个 macrotask 执行前，把所有已压入 microtask 的任务全部执行
    5.  直到 microtask 没有了，再执行下一个 macrotask
    6.  循环至结束

## 浏览器缓存机制

1.  优点
    1.  一个优秀的缓存策略可以缩短网页请求资源的距离
    2.  减少延迟
    3.  并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷
2.  类型
    1.  强缓存
        1.  expires 过期时间（http1.0；受本地时间影响）
        2.  cache-control 过期秒数（http1.1；常用：no-cache、max-age）
    2.  协商缓存
        1.  last-modified 最后修改时间
        2.  etag 资源版本标识
3.  访问机制
    1.  输入 URL、链接标签：正常使用缓存策略
    2.  F5 刷新、右键刷新：设置 cache-control: max-age=0，强制走协商缓存
    3.  ctrl + F5 刷新：设置 cache-control: no-cache，强制获取最新的资源
4.  缓存机制判断
    1.  优先使用 强缓存
    2.  若 强缓存 生效，则直接使用缓存
    3.  若 强缓存 失效，则使用 协商缓存（协商缓存由服务器决定是否使用缓存）
    4.  若 协商缓存 生效（304），则继续使用缓存
    5.  若 协商缓存 失效，代表缓存失效，将重新获取资源（200）和缓存标识
5.  实际应用场景策略
    1.  频繁变动的资源：（Cache-Control: no-cache）
    2.  不常变化的资源：（Cache-Control: max-age=31536000）
        而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已)。
        1.  覆盖式发布：a.css?v=hash
        2.  非覆盖式发布：a_hash.css
6.  静态资源缓存优化方案
    1.  本地缓存：节省带宽
    2.  内容摘要版本：精准缓存检测
    3.  CDN：优化网络请求
    4.  非覆盖式发布：平滑升级、备份（易于回滚）

# html

1.  html 语义化

# css

1.  布局类型
    1.  静态布局：（PC：定 min-width，MOB：定 max-width）
    2.  自适应布局：（media query，元素不变，布局改变，位置改变）
    3.  流式布局(百分比布局)：（左固定右自适应、左右固定中自适应）
    4.  弹性布局
    5.  响应式布局：为不同分辨率创建流式布局
2.  布局方案
    1.  两栏布局、三栏布局
        0.  table
        1.  双飞翼、圣杯
        1.  float + margin
        1.  absolute + left/right
        1.  flex
        1.  grid + grid-template-colomns: 左 width auto 右 width
3.  中心居中
    0.  other: table-cell
    1.  ie8: vertical-align:middle + 全高伪元素 + text-align:center/margin:auto
    1.  ie8： absolute + left/right/top/bottom:0 + margin:auto
    1.  ie9: absolute + top/left:50% + transform:translate(-50%, -50%)
    1.  ie10: flex + justify-content + align-items
    1.  ie11: grid + grid-template-rows:auto (height) auto + grid-template-colomns:auto (width) auto

# JS

## 数据

1.  数据类型
    1.  基本类型：Number、String、Boolean、Null、Undefined、Symbol（ES6）
    2.  引用类型：Object（在 JS 中除了基本数据类型以外的都是对象，数据是对象，函数是对象，正则表达式是对象）
2.  栈(stack) 和 堆(heap)
    1.  stack 会自动分配内存空间，会自动释放，存放基本类型，简单的数据段，占据固定大小的空间。
    2.  heap 动态分配的内存，大小不定也不会自动释放，存放引用类型，指那些可能由多个值构成的对象，保存在堆内存中，包含引用类型的变量，实际上保存的不是变量本身，而是指向该对象的指针。
3.  内存分配和垃圾回收
    1.  一般来说栈内存线性有序存储，容量小，系统分配效率高。而堆内存首先要在堆内存新分配存储区域，之后又要把指针存储到栈内存中，效率相对就要低一些了。
    2.  垃圾回收方面，栈内存变量基本上用完就回收了，而推内存中的变量因为存在很多不确定的引用，只有当所有调用的变量全部销毁之后才能回收。
4.  类型判断
    1.  typeof：基本类型的判断的最佳方法（P.S：判断 null 会返回 object）、引用类型均返回 object
    2.  instanceof：查看是否处在原型链
    3.  Object.prototype.toString.call()：最佳查询类型方法
5.  浅拷贝 和 深拷贝
    1.  浅拷贝：基本类型为传值、引用类型为传址（指针）
    2.  深拷贝：使用递归解决传址问题
        1.  deepClone 方法：判断如为非 object 类型则返回，如为 object 类型则继续递归调用 deepClone
        2.  JSON.parse(JSON.stringify(obj))
        3.  扩展运输符
        4.  Object.assign({}, ...)
6.  隐式转换
    1.  手动转类型
        1.  其它转 Number
            1.  var n = +target
            2.  var n = target \* 1
        2.  其它转 String
            1.  var s = target + ''
        3.  其它转 Boolean
            1.  var b = !!target
    2.  == 与 ===
        1.  ===：类型与值（或引用地址）必须相同
        2.  ==
            1.  类型相同时，进行===比较
            2.  类型不同时，把值转换为数值再比较

## 原型链和继承

1.  概念
    1.  对象
    2.  继承
    3.  构造器 constructor
    4.  new 关键字 与 构造函数
    5.  构造函数 —> 实例对象
    6.  属性与方法的共享（X）
        原型属性的引入（√）
2.  函数对象
    1.  凡是通过 new Function（或 function 关键字）创建的都是 函数对象
    2.  函数对象拥有 prototype 属性（原型对象）
        1.  此对象拥有 `__proto__`属性
        2.  拥有 constructor 属性（构造器属性）
3.  实例对象的隐性原型（`__proto__`） === 构造函数的显性原型（prototype）

```
    dog1.__proto__ === Dog.prototype
    (Dog.prototype).__proto__ === Object.prototype
```

## 函数式编程

## this 指向

1.  普通函数中的 this：
    1.  this 总是代表它的直接调用者, 例如 obj.function ,那么 function 中的 this 就是 obj;
    2.  在默认情况(非严格模式下,未使用 'use strict'),没找到直接调用者,则 this 指的是 window;
    3.  在严格模式下,没有直接调用者的函数中的 this 是 undefined;
    4.  使用 call, apply, bind(ES5 新增)绑定的,this 指的是 绑定的对象。
2.  箭头函数中的 this：
    1.  箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值，自己本身并没有 this 值；
    2.  箭头函数的 this 永远指向其上下文的 this，任何方法都改变不了其指向，如 call(), bind(), apply()。
3.  总结
    1.  普通函数中的 this：谁调用此函数，this 就指向谁
    2.  箭头函数中的 this：箭头函数没有 this，捕获其所在上下文环境的 this 作为自己的 this

## call、apply、bind

> 用于改变 this 指向，但无法对箭头函数使用

1.  call、apply 会自动执行
2.  bind 返回一个函数，需要手动执行

## ES5 和 ES6

# 跨域

1.  ie10+
    使用 CORS
    1.  简单请求（HEAD、GET、POST、无自定义头信息）
        请求头自动添加 origin 字段，与服务器 allow 字段匹配（Access-Control-Allow-Origin）
    2.  非简单请求（content-type/json 等）
        会发起 option 预检请求（Access-Control-Max-Age）
2.  ie8、ie9
    使用 XDomainRequest
    1.  crossDomain：true
    2.  xhrFields： {
        withCredentials：true
        }
3.  ie7-
    JSONP（仅限 GET 方法）：动态创建 script 标签，再通过回调方法获取数据
4.  ie7-
    document.domain + iframe
    location.hash + iframe
    window.name + iframe
    postMessage
5.  其它方案
    1.  Nginx 反向代理
    2.  Proxy 正向代理
        1.  http-proxy-middleware
        2.  webpack-dev-server
    3.  Mockjs 本地代理

# 兼容性

1.  html
    1.  hack
2.  css
    1.  初始化样式：Normalize.css
    2.  浏览器兼容前缀：autoprefixer
    3.  hack
    4.  布局
        1.  ie8：float、absolute、margin
        2.  ie9：transform
        3.  ie10：flex
        4.  ie11：grid
3.  js
    1.  es6 转 es5
        1.  babel：只转换新的句法
        2.  polyfill：转换新的 API
    2.  es5、es6 使用
        1.  PC：ie9
        2.  Mobile
            1.  ios：ios10.0 以上支持 es6
            2.  Android：不支持 es6，需要转成 es5

# 分辨率

1.  px2rem
    1.  standardFontSize = clientWidth / (designWidth / remUnit) + 'px'
    2.  px2remLoader = {
        loader: 'px2rem-loader',
        options: {
        remUnit: 100 // rem 与 px 相转换的比例系数
        }
        }
2.  media query

# 性能优化

代码 - 打包 - 加载/渲染 - 体验 - 安全

- 减少代码量
- 减少请求量
- 加快渲染速度

1.  代码
    1.  代码检查
        1.  eslint
        2.  prettier/jsbeautify
        3.  vetur
    2.  html
        1.  style 放头部、script 放尾部 defer 加载
        2.  语义化标签
        3.  减少 iframe 使用
    3.  css
        1.  了解 Repaint 和 Reflow
        2.  用 class 代替 dom.style
        3.  动画类使用 fixed/absolute
        4.  使用 css 代替 img/js 实现图案或交互
    4.  js
        1.  工具函数
        2.  数据模板、组件、布局
        3.  使用 js 变量代替存储内容
        4.  减少 dom 操作，大量 dom 操作一次性写入，可使用虚拟 dom
        5.  异步代替同步
        6.  使用 json 进行数据交互
    5.  storage
        1.  只保存必要简要信息
        2.  localStorage
            1.  themeStyle
            2.  userInfo
        3.  sessionStorage
            1.  dictionary
            2.  static data（e.g. region）
2.  打包/编译
    1.  压缩（minify、uglify...）
    2.  清除注释（生产环境）
    3.  不使用 sourcemap（可选）
    4.  自动补全（autofixer、babel、polyfill...）
    5.  webpack-bundle-analyzer 分析、按需引入
        1.  lodash -> lodash/core
        2.  moment -> moment/src/moment
        3.  vue-echarts -> vue-echarts/components/Echarts.vue
3.  请求/加载/渲染
    1.  img
        1.  生成图片尺寸库，根据不同情境使用
        2.  合理使用 css sprites
        3.  合理使用 base64
            1.  url-loader 转换，通常限制在 32kb
            2.  经过 base64 编码的图片没有 http 请求，可解决跨域、缓存等问题
    2.  gzip 压缩
    3.  将公用的 js 库通过 script 标签外部引入并行下载
    4.  CDN、多域名存储静态资源（同名域名同时并发请求数为 4/6/8）
    5.  DNS
        1.  减少 DNS 查询（减少不同主机名的数量同时也减少了页面能够并行下载的组件数量，避免 DNS 查找削减了响应时间，而减少并行下载数量却增加了响应时间。我的原则是把组件分散在 2 到 4 个主机名下，这是同时减少 DNS 查找和允许高并发下载的折中方案。）
        2.  DNS 预加载（DNS Prefetch）
    6.  合理使用浏览器缓存机制（强缓存 + 版本号更新）
    7.  不重复请求相同接口的相同资源
    8.  数据存储
        1.  localStorage（themeStyle、userInfo）
        2.  sessionStorage（dictionary、static data）
        3.  store
    9.  No 404
        1.  vue-router hash 模式下配置`/*`的 redirect；history 模式下后端配合返回 index/login
    10. 按需加载
        1.  vue-router + require.ensure() 实现组件模块化加载
    11. 懒加载
        1.  图片懒加载
            1.  原理：监听滚动距离，对比图片位置
            2.  实现：
                1.  渲染不加载，src 为空，使用 data-src 存储
                2.  创建 load 函数
                3.  绑定 onscroll 事件，并首次调用达到首屏加载
        2.  其它
            1.  条件加载
            2.  延迟加载
            3.  首绘加载
    12. 减少 repaint 重绘和 reflow 重排
        1.  尽量少用 style 属性，用 class 重绘比重排的效率高
        2.  有动画效果的元素设置绝对定位和固定定位
        3.  权衡速度的平滑。比如实现一个动画，以 1 个像素为单位移动这样最平滑，但 reflow 就会过于频繁，CPU 很快就会被完全占用。如果以 3 个像素为单位移动就会好很多。
        4.  减少不必要的 dom 层级，不要频繁操作 dom
4.  用户体验
    1.  预加载、loading 图、骨架屏
    2.  transition、animate
    3.  overflow-scrolling：touch
    4.  scrollbar：none
5.  安全问题
    1.  XSS（跨站脚本攻击）
        1.  定义：通过对网页注入可执行代码且成功地被浏览器执行，达到攻击的目的
        2.  条件：1.需要向 web 页面注入恶意代码；2.这些恶意代码能够被浏览器成功的执行
        3.  类型：反射型、存储型
        4.  防范：
            1.  过滤用户输入是否包含非法字符
            2.  提交参数进行 url 过滤并进行字符转义
            3.  标签白名单代替黑名单（富文本等）
    2.  CSRF（跨站请求伪造）
        1.  定义：通过伪装来自受信任用户的请求来进行对受信任的网站一些操作
        2.  条件：1.用户已有登录态信息；2.用户被诱导执行提交操作
        3.  防范：
            1.  请求头添加 refer
            2.  使用 token，放置在 header 里

# Vue 全家桶

## Vue

> Vue 的`本质`就是用一个 `Function` 实现的 Class，然后在它的原型 `prototype` 和本身上面扩展一些属性和方法。
> Vue 的`核心思想`是`数据驱动`。所谓的数据驱动，是指`视图是由数据驱动生成`的，对`视图的修改`，不再直接操作 DOM，而是通过`修改数据`。我们所关心的只是`数据的修改，DOM 变成了数据的映射`。
> Vue 的`工作机制`是采用数据劫持结合发布者-订阅者模式，通过核心方法 Object.defineProperty()劫持数据，在数据

常见问题

1.  vue 优缺点
    1.  优点
    2.  缺点
        1.  ie9+：Object.defineProperty 是 es5 语法，并且无法被 shim
        2.  不利于 SEO：单页面应用
2.  vue data 的格式不是对象而是使用 return 语句返回
    1.  `组件是可复用的 vue 实例`：一个组件被创建好之后，就可能被用在各个地方，而组件不管被复用了多少次，组件中的 data 数据都应该是相互隔离，互不影响的，基于这一理念，组件每复用一次，data 数据就应该被复制一次，之后，当某一处复用的地方组件内 data 数据被改变时，其他复用地方组件的 data 数据不受影响
    2.  `Object 是引用类型`：定义变量时其实是会指向相同地址
    3.  `函数存在作用域`：数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的 data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。
3.  vue 中数据监听问题
    1.  无法对数组下标进行监听
        (https://cn.vuejs.org/v2/guide/list.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9)
        1.  使用 Vue.set(vm.items, indexOfItem, newValue) / vm.$set() 来修改下标对应值
        2.  使用被包裹的变异方法：push()、pop()、shift()、unshift()、splice()、sort()、reverse()
        3.  使用替换方法：filter()、concat()、slice()
    2.  无法对对象属性添加或删除进行监听
        (https://cn.vuejs.org/v2/guide/list.html#%E5%AF%B9%E8%B1%A1%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9)
        1.  使用 Vue.set(vm.obj, newKey, newValue) / vm.$set() 来添加单个响应式属性（不允许对根级别，只允许嵌套级别）
        2.  使用 Object.assign({}, oldObj, extendsObj)覆盖，来添加多个响应式属性
    3.  正常深层监听对象
        1.  使用 watch 监听（deep：true）
    4.  vue3.0 优化
        1.  使用 proxy 取代了 Object.defineProperty

概念

1.  vue 文件解析（.vue 单文件组件 (SFC) 规范）
    1.  `<template>`模板块
    2.  `<script>`脚本块
    3.  `<style>`样式块
2.  模板渲染
    1.  基本渲染流程
        1.  new Vue(options)
        2.  merge options 合并配置
        3.  initLifecycle 初始化生命周期
        4.  initEvents 初始化事件中心
        5.  initRender 初始化渲染函数
        6.  触发`beforeCreate`
        7.  initState 初始化状态值
            1.  props
            2.  methods
            3.  data
            4.  computed
            5.  watch
        8.  触发`created`
        9.  $mount 渲染
            1.  check render 检查 render 函数
            2.  触发`beforeMount`
                1.  render
                    1.  template 转换为 AST
                    2.  AST 生成 render 函数：`vm._c()`
                    3.  render 函数中判断节点是 tag 还是 已注册的 component，使用不同方法生成 vnode
                        1.  tag：createElement
                        2.  component：createComponent
                    4.  调用 updateComponent
                    5.  判断为根节点时，设置 `vm._isMounted` 为 true
            3.  触发`mounted`
        10. updateComponent 组件更新
            1.  触发`beforeUpdate`
            2.  调用 watcher 的 update 更新 dom
            3.  触发`updated`
    2.  根组件节点、子组件 component 节点、文本节点的渲染、插槽 slot 节点的渲染
        1.  根组件节点：`vm._c()`
        2.  component 节点：`vm._c()`
        3.  文本节点：`vm._v()`
        4.  slot 节点：`vm._t()`
3.  生命周期
    1.  beforeCreate():实例在内存中被创建出来，还没有初始化好 data 和 methods 属性。
    2.  create():实例已经在内存中创建，已经初始化好 data 和 method，此时还没有开始编译模板。
    3.  beforeMount():已经完成了模板的编译，还没有挂载到页面中。
    4.  mounted()：将编译好的模板挂载到页面指定的容器中显示。
    5.  beforeUpdate():状态更新之前执行函数，此时 data 中的状态值是最新的，但是界面上显示的数据还是旧的，因为还没有开始重新渲染 DOM 节点。
    6.  updated():此时 data 中的状态值和界面上显示的数据都已经完成了跟新，界面已经被重新渲染好了！
    7.  beforeDestroy():实例被销毁之前。
    8.  destroyed():实例销毁后调用，Vue 实例指示的所有东西都会解绑，所有的事件监听器都会被移除,所有的子实例也都会被销毁。组件已经被完全销毁，此时组建中所有 data、methods、以及过滤器，指令等，都已经不可用了。
4.  双向绑定
    1.  模块
        1.  Observer 监听者：用来`劫持`并监听所有属性，如果有变动的，就`通知订阅者`
            1.  new Dep()
            2.  Object.defineProperty
                1.  getter
                    1.  判断触发 dep.addSub 添加依赖
                2.  setter
                    1.  触发 dep.notify 集体更新
        2.  Dep 订阅者管理器：用于储存`订阅者依赖`和`集体发布更新`
            1.  addSub
            2.  notify
        3.  Watcher 订阅者：可以`收到属性的变化通知`并`执行相应的函数`，从而更新视图
            1.  get
                1.  传递到 Dep.target 证明当前计算依赖
                2.  自调用触发 Observer 的 getter，以至触发 dep.addSub 添加依赖
            2.  update
        4.  Compile 指令解析器：可以扫描和解析每个节点的相关`指令`，并根据`初始化模板数据`以及`初始化相应的订阅器`
            1.  解析节点类型（用 node.nodeType）
                1.  elementNode
                2.  textNode
            2.  解析指令模板（用 node.attributes）
            3.  Compiler 解析指令
                1.  text
                2.  model
                3.  event
            4.  绑定
                1.  Updater
                    1.  text：node.textContent
                    2.  model：node.value
                2.  event：addEventListener
            5.  执行
                1.  初始化执行 Updater
                2.  订阅执行 new Watcher() 添加依赖
5.  响应式原理
    1.  对`data`中的属性进行`observe`，调用`Object.defineProperty`监听，并`创建dep`
    2.  `Compile`解析模板时，调用`new Watcher()`对 text 和 model 节点进行依赖收集
    3.  `watcher 初始化时`会赋值`Dep.target`证明正在计算依赖的是自己，然后强制执行`Observer`中的`get`，触发添加依赖到相应的`dep`中
    4.  当`data属性值变化`时，触发 `其Observer的setter`，再触发 `其dep.notify`，再触发 `其watcher的update`，再判断值被修改的才进行 cb，达到更新相应节点视图
        `此处才是虚拟节点控制只更新修改值视图的核心`
    5.  `store` 响应式的原理也是类似的，new Vuex.Store 的过程也会对 state 进行 observe
6.  component 组件
    1.  组件渲染
    2.  组件通信
        1.  跳转通信
            1.  使用 vue-router 的 query 或 params
        2.  父子组件通信：
            1.  props 和 emit
                1.  :props 向子传递属性
                2.  @emit 向父传递更新
            2.  $attr 和 $listen (2.4.0+)
                (https://cn.vuejs.org/v2/api/#vm-attrs)
                (https://www.jianshu.com/p/4649d317adfe)
                1.  v-bind="$attrs" 向子传递属性
                2.  v-on="$listeners" 向子传递绑定事件
            3.  只进不出，或者只用于控制视图
                1.  slot 插槽
        3.  兄弟组件通信：event bus（事件总线）
            1.  bus.$on()绑定，bus.$emit()触发
        4.  其它组件通信
            1.  使用 vuex
7.  computed 计算属性
    1.  定义：计算属性可用于快速计算视图（View）中显示的属性。这些计算将`被缓存`，并且只在需要时更新。
    2.  对比：
        1.  vs data：computed 的作用趋向于通过复杂计算得出的‘结果’，`尽量不需要用户手动改变`。
        2.  vs methods：computed 会`记住计算的属性所依赖的值`，只有在依赖变化时才计算值。而 method 会每次都执行一次。
        3.  vs watcher：computed 为 `1或多个属性`控制 `1个值`。watcher 为 `1个属性`控制`后续相关流程`。
8.  slot 定制模板
    1.  定义：可以理解为`将parent的 子组件标签内 的一段html内容`注入到`child组件的slot插槽`中
    2.  渲染：
        1.  调用`vm._t()`，即调用 renderSlot
            1.  传入 name、fallback
                1.  name 为 slot 的名，不传默认为 default
                2.  fallback 为 slot 内部的默认值
            2.  所以渲染时能判断：自定义组件中有传入子元素就渲染子元素，没有就使用默认插槽里面的值
            3.  再调用 resolveSlots 对 name 进行归类和过滤处理
            4.  最后返回 vnode
    3.  类型：
        1.  编译作用域
        2.  后备内容
        3.  具名插槽
        4.  作用域插槽
        5.  独占默认插槽
        6.  结构插槽
        7.  动态插槽
        8.  简写方式
9.  nextTick
    1.  涉及概念
        1.  vue 中 Dom 的异步更新
        2.  浏览器的线程（js 引擎的运行机制、任务队列 task queue、事件循环 Event Loop）
    2.  实现方法
        1.  Promise.then
        2.  MutationObserver
        3.  setTimeout(fn, 0)
    3.  使用方法
        1.  nextTick 会返回一个 Promise，所以可以直接使用 callback、或者 await 进行更新后的处理

## Vue-router

1.  定义：vue 路由管理器
2.  跳转方式
    1.  router-link
    2.  $router.push 入栈跳转
    3.  $router.replace 无入栈跳转
    4.  $router.go
3.  参数传递
    1.  query（地址栏显示）
    2.  params（地址栏不显示）
        1.  使用 path 来跳转的话，params 不生效
4.  钩子函数
    1.  全局拦截器
        1.  router.beforeEach
        2.  router.afterEach
    2.  独享守卫钩子
        (https://www.cnblogs.com/lhl66/p/9195901.html)
        1.  beforeRouteEnter
        2.  beforeRouteUpdate
        3.  beforeRouteLeave
5.  其它问题
    1.  解决跳转后返回需要指定 tab 功能

```js
this.$router.replace(
  {
    name: 'thisRoute',
    query: { tabIndex: this.activeTab }
  },
  () => {
    this.$router.push({
      name: 'nextRoute'
    });
  }
);
```

## Vuex

1.  定义：vue 状态管理器
2.  模块
    1.  state 状态数据库
    2.  getters 取出状态
    3.  mutations 修改状态
    4.  mutation-types 使用常量替代 Mutation 事件类型
    5.  actions 异步提交 mutation
    6.  modules 模块化状态数据库
3.  命名空间 namespaced
4.  其它问题
    1.  解决页面刷新 vuex 保存至丢失问题
        1.  使用 localStorage 保存 userInfo、theme style 等
        2.  使用 sessionStorage 保存 static data
        3.  vuex-persistedstate
            (https://www.jianshu.com/p/c22861ec5f21)

## axios

1.  定义：基于 promise 的 HTTP 库
2.  interceptors 全局拦截器
    1.  axios.interceptors.request.use()
        1.  请求头传入 token
    1.  axios.interceptors.response.use()
3.  二次封装

```js
// 创建 axios 实例
const service = axios.create();

export const get = (url: any, params?: any) => {
  return new Promise((resolve, reject) => {
    service
      .get(url, { params: params })
      .then((res: any) => {
        resolve(res); // 返回请求成功的数据 data
      })
      .catch((err: any) => {
        reject(err);
      });
  });
};
export const post = (url: any, params?: any) => {
  return new Promise((resolve, reject) => {
    service
      .post(url, qs.stringify(params))
      .then((res: any) => {
        resolve(res);
      })
      .catch((err: any) => {
        reject(err);
      });
  });
};

Vue.prototype.$post = post;
Vue.prototype.$get = get;
```
